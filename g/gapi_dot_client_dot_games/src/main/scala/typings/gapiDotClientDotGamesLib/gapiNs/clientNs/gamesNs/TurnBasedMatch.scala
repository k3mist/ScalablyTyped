package typings
package gapiDotClientDotGamesLib.gapiNs.clientNs.gamesNs

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait TurnBasedMatch extends js.Object {
  /** The ID of the application being played. */
  var applicationId: js.UndefOr[java.lang.String] = js.undefined
  /** Criteria for auto-matching players into this match. */
  var autoMatchingCriteria: js.UndefOr[TurnBasedAutoMatchingCriteria] = js.undefined
  /** Details about the match creation. */
  var creationDetails: js.UndefOr[TurnBasedMatchModification] = js.undefined
  /** The data / game state for this match. */
  var data: js.UndefOr[TurnBasedMatchData] = js.undefined
  /**
    * This short description is generated by our servers based on turn state and is localized and worded relative to the player requesting the match. It is
    * intended to be displayed when the match is shown in a list.
    */
  var description: js.UndefOr[java.lang.String] = js.undefined
  /** The ID of the participant that invited the user to the match. Not set if the user was not invited to the match. */
  var inviterId: js.UndefOr[java.lang.String] = js.undefined
  /** Uniquely identifies the type of this resource. Value is always the fixed string games#turnBasedMatch. */
  var kind: js.UndefOr[java.lang.String] = js.undefined
  /** Details about the last update to the match. */
  var lastUpdateDetails: js.UndefOr[TurnBasedMatchModification] = js.undefined
  /** Globally unique ID for a turn-based match. */
  var matchId: js.UndefOr[java.lang.String] = js.undefined
  /** The number of the match in a chain of rematches. Will be set to 1 for the first match and incremented by 1 for each rematch. */
  var matchNumber: js.UndefOr[scala.Double] = js.undefined
  /** The version of this match: an increasing counter, used to avoid out-of-date updates to the match. */
  var matchVersion: js.UndefOr[scala.Double] = js.undefined
  /** The participants involved in the match, along with their statuses. Includes participants who have left or declined invitations. */
  var participants: js.UndefOr[js.Array[TurnBasedMatchParticipant]] = js.undefined
  /** The ID of the participant that is taking a turn. */
  var pendingParticipantId: js.UndefOr[java.lang.String] = js.undefined
  /** The data / game state for the previous match; set for the first turn of rematches only. */
  var previousMatchData: js.UndefOr[TurnBasedMatchData] = js.undefined
  /** The ID of a rematch of this match. Only set for completed matches that have been rematched. */
  var rematchId: js.UndefOr[java.lang.String] = js.undefined
  /** The results reported for this match. */
  var results: js.UndefOr[js.Array[ParticipantResult]] = js.undefined
  /**
    * The status of the match.
    * Possible values are:
    * - "MATCH_AUTO_MATCHING" - One or more slots need to be filled by auto-matching; the match cannot be established until they are filled.
    * - "MATCH_ACTIVE" - The match has started.
    * - "MATCH_COMPLETE" - The match has finished.
    * - "MATCH_CANCELED" - The match was canceled.
    * - "MATCH_EXPIRED" - The match expired due to inactivity.
    * - "MATCH_DELETED" - The match should no longer be shown on the client. Returned only for tombstones for matches when sync is called.
    */
  var status: js.UndefOr[java.lang.String] = js.undefined
  /**
    * The status of the current user in the match. Derived from the match type, match status, the user's participant status, and the pending participant for
    * the match.
    * Possible values are:
    * - "USER_INVITED" - The user has been invited to join the match and has not responded yet.
    * - "USER_AWAITING_TURN" - The user is waiting for their turn.
    * - "USER_TURN" - The user has an action to take in the match.
    * - "USER_MATCH_COMPLETED" - The match has ended (it is completed, canceled, or expired.)
    */
  var userMatchStatus: js.UndefOr[java.lang.String] = js.undefined
  /** The variant / mode of the application being played; can be any integer value, or left blank. */
  var variant: js.UndefOr[scala.Double] = js.undefined
  /** The ID of another participant in the match that can be used when describing the participants the user is playing with. */
  var withParticipantId: js.UndefOr[java.lang.String] = js.undefined
}

object TurnBasedMatch {
  @scala.inline
  def apply(
    applicationId: java.lang.String = null,
    autoMatchingCriteria: TurnBasedAutoMatchingCriteria = null,
    creationDetails: TurnBasedMatchModification = null,
    data: TurnBasedMatchData = null,
    description: java.lang.String = null,
    inviterId: java.lang.String = null,
    kind: java.lang.String = null,
    lastUpdateDetails: TurnBasedMatchModification = null,
    matchId: java.lang.String = null,
    matchNumber: scala.Int | scala.Double = null,
    matchVersion: scala.Int | scala.Double = null,
    participants: js.Array[TurnBasedMatchParticipant] = null,
    pendingParticipantId: java.lang.String = null,
    previousMatchData: TurnBasedMatchData = null,
    rematchId: java.lang.String = null,
    results: js.Array[ParticipantResult] = null,
    status: java.lang.String = null,
    userMatchStatus: java.lang.String = null,
    variant: scala.Int | scala.Double = null,
    withParticipantId: java.lang.String = null
  ): TurnBasedMatch = {
    val __obj = js.Dynamic.literal()
    if (applicationId != null) __obj.updateDynamic("applicationId")(applicationId)
    if (autoMatchingCriteria != null) __obj.updateDynamic("autoMatchingCriteria")(autoMatchingCriteria)
    if (creationDetails != null) __obj.updateDynamic("creationDetails")(creationDetails)
    if (data != null) __obj.updateDynamic("data")(data)
    if (description != null) __obj.updateDynamic("description")(description)
    if (inviterId != null) __obj.updateDynamic("inviterId")(inviterId)
    if (kind != null) __obj.updateDynamic("kind")(kind)
    if (lastUpdateDetails != null) __obj.updateDynamic("lastUpdateDetails")(lastUpdateDetails)
    if (matchId != null) __obj.updateDynamic("matchId")(matchId)
    if (matchNumber != null) __obj.updateDynamic("matchNumber")(matchNumber.asInstanceOf[js.Any])
    if (matchVersion != null) __obj.updateDynamic("matchVersion")(matchVersion.asInstanceOf[js.Any])
    if (participants != null) __obj.updateDynamic("participants")(participants)
    if (pendingParticipantId != null) __obj.updateDynamic("pendingParticipantId")(pendingParticipantId)
    if (previousMatchData != null) __obj.updateDynamic("previousMatchData")(previousMatchData)
    if (rematchId != null) __obj.updateDynamic("rematchId")(rematchId)
    if (results != null) __obj.updateDynamic("results")(results)
    if (status != null) __obj.updateDynamic("status")(status)
    if (userMatchStatus != null) __obj.updateDynamic("userMatchStatus")(userMatchStatus)
    if (variant != null) __obj.updateDynamic("variant")(variant.asInstanceOf[js.Any])
    if (withParticipantId != null) __obj.updateDynamic("withParticipantId")(withParticipantId)
    __obj.asInstanceOf[TurnBasedMatch]
  }
}

